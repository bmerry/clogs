<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CLOGS: clogs::Scan Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CLOGS
   </div>
   <div id="projectbrief">C++ library for sorting and searching in OpenCL applications</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classclogs_1_1Scan.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classclogs_1_1Scan-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">clogs::Scan Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Exclusive scan (prefix sum) primitive.  
 <a href="classclogs_1_1Scan.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="scan_8h_source.html">scan.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for clogs::Scan:</div>
<div class="dyncontent">
<div class="center"><img src="classclogs_1_1Scan__inherit__graph.png" border="0" usemap="#clogs_1_1Scan_inherit__map" alt="Inheritance graph"/></div>
<map name="clogs_1_1Scan_inherit__map" id="clogs_1_1Scan_inherit__map">
<area shape="rect" id="node2" href="classclogs_1_1Algorithm.html" title="Base class for all algorithm classes. " alt="" coords="5,5,121,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for clogs::Scan:</div>
<div class="dyncontent">
<div class="center"><img src="classclogs_1_1Scan__coll__graph.png" border="0" usemap="#clogs_1_1Scan_coll__map" alt="Collaboration graph"/></div>
<map name="clogs_1_1Scan_coll__map" id="clogs_1_1Scan_coll__map">
<area shape="rect" id="node2" href="classclogs_1_1Algorithm.html" title="Base class for all algorithm classes. " alt="" coords="5,5,121,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a538f2cfd9bf70df336044f915e7acdd9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclogs_1_1Scan.html#a538f2cfd9bf70df336044f915e7acdd9">Scan</a> ()</td></tr>
<tr class="memdesc:a538f2cfd9bf70df336044f915e7acdd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a538f2cfd9bf70df336044f915e7acdd9">More...</a><br /></td></tr>
<tr class="separator:a538f2cfd9bf70df336044f915e7acdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad057af8a6c02016da5b650d1d9a7f147"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclogs_1_1Scan.html#ad057af8a6c02016da5b650d1d9a7f147">Scan</a> (const cl::Context &amp;context, const cl::Device &amp;device, const <a class="el" href="classclogs_1_1Type.html">Type</a> &amp;type)</td></tr>
<tr class="memdesc:ad057af8a6c02016da5b650d1d9a7f147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ad057af8a6c02016da5b650d1d9a7f147">More...</a><br /></td></tr>
<tr class="separator:ad057af8a6c02016da5b650d1d9a7f147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde3f6389fc52be74c8231ddd3b2df87"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclogs_1_1Scan.html#acde3f6389fc52be74c8231ddd3b2df87">Scan</a> (const cl::Context &amp;context, const cl::Device &amp;device, const <a class="el" href="classclogs_1_1ScanProblem.html">ScanProblem</a> &amp;problem)</td></tr>
<tr class="memdesc:acde3f6389fc52be74c8231ddd3b2df87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#acde3f6389fc52be74c8231ddd3b2df87">More...</a><br /></td></tr>
<tr class="separator:acde3f6389fc52be74c8231ddd3b2df87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d53b3d1264f5fe5e2b867d65ba8061"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91d53b3d1264f5fe5e2b867d65ba8061"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclogs_1_1Scan.html#a91d53b3d1264f5fe5e2b867d65ba8061">~Scan</a> ()</td></tr>
<tr class="memdesc:a91d53b3d1264f5fe5e2b867d65ba8061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a91d53b3d1264f5fe5e2b867d65ba8061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ad3dfe7cac4f39d0dc70db63fbfde0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclogs_1_1Scan.html#af6ad3dfe7cac4f39d0dc70db63fbfde0">enqueue</a> (const cl::CommandQueue &amp;commandQueue, const cl::Buffer &amp;buffer,::size_t elements, const void *offset=NULL, const VECTOR_CLASS&lt; cl::Event &gt; *events=NULL, cl::Event *event=NULL)</td></tr>
<tr class="memdesc:af6ad3dfe7cac4f39d0dc70db63fbfde0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a scan operation on a command queue (in-place).  <a href="#af6ad3dfe7cac4f39d0dc70db63fbfde0">More...</a><br /></td></tr>
<tr class="separator:af6ad3dfe7cac4f39d0dc70db63fbfde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4884cf37a5948ca69d251e10466092"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclogs_1_1Scan.html#a4b4884cf37a5948ca69d251e10466092">enqueue</a> (const cl::CommandQueue &amp;commandQueue, const cl::Buffer &amp;inBuffer, const cl::Buffer &amp;outBuffer,::size_t elements, const void *offset=NULL, const VECTOR_CLASS&lt; cl::Event &gt; *events=NULL, cl::Event *event=NULL)</td></tr>
<tr class="memdesc:a4b4884cf37a5948ca69d251e10466092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a scan operation on a command queue.  <a href="#a4b4884cf37a5948ca69d251e10466092">More...</a><br /></td></tr>
<tr class="separator:a4b4884cf37a5948ca69d251e10466092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddfae11e9f0418afef0b5c23164b65a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclogs_1_1Scan.html#a4ddfae11e9f0418afef0b5c23164b65a">enqueue</a> (cl_command_queue commandQueue, cl_mem inBuffer, cl_mem outBuffer,::size_t elements, const void *offset=NULL, cl_uint numEvents=0, const cl_event *events=NULL, cl_event *event=NULL)</td></tr>
<tr class="separator:a4ddfae11e9f0418afef0b5c23164b65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15311c66eb2ca7a2348cba656fffe52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclogs_1_1Scan.html#ac15311c66eb2ca7a2348cba656fffe52">enqueue</a> (const cl::CommandQueue &amp;commandQueue, const cl::Buffer &amp;buffer,::size_t elements, const cl::Buffer &amp;offsetBuffer, cl_uint offsetIndex, const VECTOR_CLASS&lt; cl::Event &gt; *events=NULL, cl::Event *event=NULL)</td></tr>
<tr class="memdesc:ac15311c66eb2ca7a2348cba656fffe52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a scan operation on a command queue, with an offset in a buffer (in-place).  <a href="#ac15311c66eb2ca7a2348cba656fffe52">More...</a><br /></td></tr>
<tr class="separator:ac15311c66eb2ca7a2348cba656fffe52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff4a4bc639c825357fed42e8c7ae9b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclogs_1_1Scan.html#a3ff4a4bc639c825357fed42e8c7ae9b4">enqueue</a> (const cl::CommandQueue &amp;commandQueue, const cl::Buffer &amp;inBuffer, const cl::Buffer &amp;outBuffer,::size_t elements, const cl::Buffer &amp;offsetBuffer, cl_uint offsetIndex, const VECTOR_CLASS&lt; cl::Event &gt; *events=NULL, cl::Event *event=NULL)</td></tr>
<tr class="memdesc:a3ff4a4bc639c825357fed42e8c7ae9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a scan operation on a command queue, with an offset in a buffer.  <a href="#a3ff4a4bc639c825357fed42e8c7ae9b4">More...</a><br /></td></tr>
<tr class="separator:a3ff4a4bc639c825357fed42e8c7ae9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a4be9a7fa18356ce82d80ebb29c215"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclogs_1_1Scan.html#a03a4be9a7fa18356ce82d80ebb29c215">enqueue</a> (cl_command_queue commandQueue, cl_mem inBuffer, cl_mem outBuffer,::size_t elements, cl_mem offsetBuffer, cl_uint offsetIndex, cl_uint numEvents=0, const cl_event *events=NULL, cl_event *event=NULL)</td></tr>
<tr class="separator:a03a4be9a7fa18356ce82d80ebb29c215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classclogs_1_1Algorithm"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classclogs_1_1Algorithm')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classclogs_1_1Algorithm.html">clogs::Algorithm</a></td></tr>
<tr class="memitem:a52929473cab88ebdd3ec877c10bd910a inherit pub_methods_classclogs_1_1Algorithm"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclogs_1_1Algorithm.html#a52929473cab88ebdd3ec877c10bd910a">setEventCallback</a> (void(*callback)(const cl::Event &amp;, void *), void *userData, void(*free)(void *)=NULL)</td></tr>
<tr class="memdesc:a52929473cab88ebdd3ec877c10bd910a inherit pub_methods_classclogs_1_1Algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a callback function that will receive a list of all underlying events.  <a href="#a52929473cab88ebdd3ec877c10bd910a">More...</a><br /></td></tr>
<tr class="separator:a52929473cab88ebdd3ec877c10bd910a inherit pub_methods_classclogs_1_1Algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5dfefead5dcd8123a4d523691fae8fd inherit pub_methods_classclogs_1_1Algorithm"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad5dfefead5dcd8123a4d523691fae8fd inherit pub_methods_classclogs_1_1Algorithm"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classclogs_1_1Algorithm.html#ad5dfefead5dcd8123a4d523691fae8fd">setEventCallback</a> (const T &amp;callback)</td></tr>
<tr class="memdesc:ad5dfefead5dcd8123a4d523691fae8fd inherit pub_methods_classclogs_1_1Algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.The provided function object will be passed a cl::Event.  <a href="#ad5dfefead5dcd8123a4d523691fae8fd">More...</a><br /></td></tr>
<tr class="separator:ad5dfefead5dcd8123a4d523691fae8fd inherit pub_methods_classclogs_1_1Algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a11571fdf51ed05f81c9933bbaf968 inherit pub_methods_classclogs_1_1Algorithm"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclogs_1_1Algorithm.html#ab9a11571fdf51ed05f81c9933bbaf968">setEventCallback</a> (void(*callback)(cl_event, void *), void *userData, void(*free)(void *)=NULL)</td></tr>
<tr class="separator:ab9a11571fdf51ed05f81c9933bbaf968 inherit pub_methods_classclogs_1_1Algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a49c1f59d7759bac14688466b9bde07e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49c1f59d7759bac14688466b9bde07e0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>enqueue</b> (cl_command_queue commandQueue, cl_mem inBuffer, cl_mem outBuffer,::size_t elements, const void *offset, cl_uint numEvents, const cl_event *events, cl_event *event, cl_int &amp;err, const char *&amp;errStr)</td></tr>
<tr class="separator:a49c1f59d7759bac14688466b9bde07e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f16d1b6fe44322e81c37668b072023a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f16d1b6fe44322e81c37668b072023a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>enqueue</b> (cl_command_queue commandQueue, cl_mem inBuffer, cl_mem outBuffer,::size_t elements, cl_mem offsetBuffer, cl_uint offsetIndex, cl_uint numEvents, const cl_event *events, cl_event *event, cl_int &amp;err, const char *&amp;errStr)</td></tr>
<tr class="separator:a5f16d1b6fe44322e81c37668b072023a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b9c769a3e1114742e30f325cc4979a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8b9c769a3e1114742e30f325cc4979a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>moveAssign</b> (<a class="el" href="classclogs_1_1Scan.html">Scan</a> &amp;other)</td></tr>
<tr class="separator:ab8b9c769a3e1114742e30f325cc4979a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classclogs_1_1Algorithm"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classclogs_1_1Algorithm')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classclogs_1_1Algorithm.html">clogs::Algorithm</a></td></tr>
<tr class="memitem:a0460b0350e122147d9ec33ac755ca2b9 inherit pro_methods_classclogs_1_1Algorithm"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0460b0350e122147d9ec33ac755ca2b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclogs_1_1Algorithm.html#a0460b0350e122147d9ec33ac755ca2b9">moveConstruct</a> (<a class="el" href="classclogs_1_1Algorithm.html">Algorithm</a> &amp;other)</td></tr>
<tr class="memdesc:a0460b0350e122147d9ec33ac755ca2b9 inherit pro_methods_classclogs_1_1Algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs this by stealing the pointer from <em>other</em>. <br /></td></tr>
<tr class="separator:a0460b0350e122147d9ec33ac755ca2b9 inherit pro_methods_classclogs_1_1Algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1517a5659325aaece3a28885af86920d inherit pro_methods_classclogs_1_1Algorithm"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1517a5659325aaece3a28885af86920d"></a>
detail::Algorithm *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclogs_1_1Algorithm.html#a1517a5659325aaece3a28885af86920d">moveAssign</a> (<a class="el" href="classclogs_1_1Algorithm.html">Algorithm</a> &amp;other)</td></tr>
<tr class="memdesc:a1517a5659325aaece3a28885af86920d inherit pro_methods_classclogs_1_1Algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this by stealing the pointer from <em>other</em>, and returning the previous value. <br /></td></tr>
<tr class="separator:a1517a5659325aaece3a28885af86920d inherit pro_methods_classclogs_1_1Algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71faa8081a413557325ef98c59b5d2e6 inherit pro_methods_classclogs_1_1Algorithm"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71faa8081a413557325ef98c59b5d2e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclogs_1_1Algorithm.html#a71faa8081a413557325ef98c59b5d2e6">swap</a> (<a class="el" href="classclogs_1_1Algorithm.html">Algorithm</a> &amp;other)</td></tr>
<tr class="memdesc:a71faa8081a413557325ef98c59b5d2e6 inherit pro_methods_classclogs_1_1Algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the pointers between this and <em>other</em>. <br /></td></tr>
<tr class="separator:a71faa8081a413557325ef98c59b5d2e6 inherit pro_methods_classclogs_1_1Algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cfc49dbfabfd2809606632989342d1 inherit pro_methods_classclogs_1_1Algorithm"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30cfc49dbfabfd2809606632989342d1"></a>
detail::Algorithm *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclogs_1_1Algorithm.html#a30cfc49dbfabfd2809606632989342d1">getDetail</a> () const </td></tr>
<tr class="memdesc:a30cfc49dbfabfd2809606632989342d1 inherit pro_methods_classclogs_1_1Algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the embedded pointer. <br /></td></tr>
<tr class="separator:a30cfc49dbfabfd2809606632989342d1 inherit pro_methods_classclogs_1_1Algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334b913083eeec9c030d60c052f0cf04 inherit pro_methods_classclogs_1_1Algorithm"><td class="memItemLeft" align="right" valign="top">detail::Algorithm *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclogs_1_1Algorithm.html#a334b913083eeec9c030d60c052f0cf04">getDetailNonNull</a> () const </td></tr>
<tr class="memdesc:a334b913083eeec9c030d60c052f0cf04 inherit pro_methods_classclogs_1_1Algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the embedded pointer.  <a href="#a334b913083eeec9c030d60c052f0cf04">More...</a><br /></td></tr>
<tr class="separator:a334b913083eeec9c030d60c052f0cf04 inherit pro_methods_classclogs_1_1Algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873ebdcf38580120723f02b1f3a42a8b inherit pro_methods_classclogs_1_1Algorithm"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclogs_1_1Algorithm.html#a873ebdcf38580120723f02b1f3a42a8b">setDetail</a> (detail::Algorithm *ptr)</td></tr>
<tr class="memdesc:a873ebdcf38580120723f02b1f3a42a8b inherit pro_methods_classclogs_1_1Algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the embedded pointer.  <a href="#a873ebdcf38580120723f02b1f3a42a8b">More...</a><br /></td></tr>
<tr class="separator:a873ebdcf38580120723f02b1f3a42a8b inherit pro_methods_classclogs_1_1Algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a48883c64a910b48fc54f0883debdcc3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48883c64a910b48fc54f0883debdcc3a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classclogs_1_1Scan.html">Scan</a> &amp;, <a class="el" href="classclogs_1_1Scan.html">Scan</a> &amp;)</td></tr>
<tr class="separator:a48883c64a910b48fc54f0883debdcc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Exclusive scan (prefix sum) primitive. </p>
<p>One instance of this class can be reused for multiple scans, provided that</p><ul>
<li>calls to <a class="el" href="classclogs_1_1Scan.html#a4b4884cf37a5948ca69d251e10466092">enqueue</a> do not overlap; and</li>
<li>their execution does not overlap.</li>
</ul>
<p>An instance of the class is specialized to a specific context, device, and type of value to scan. Any CL integral scalar or vector type can be used.</p>
<p>The implementation is based on the reduce-then-scan strategy described at <a href="https://sites.google.com/site/duanemerrill/ScanTR2.pdf?attredirects=0">https://sites.google.com/site/duanemerrill/ScanTR2.pdf?attredirects=0</a> </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a538f2cfd9bf70df336044f915e7acdd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clogs::Scan::Scan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>The object cannot be used in this state. </p>

</div>
</div>
<a class="anchor" id="ad057af8a6c02016da5b650d1d9a7f147"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">clogs::Scan::Scan </td>
          <td>(</td>
          <td class="paramtype">const cl::Context &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cl::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclogs_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>OpenCL context to use </td></tr>
    <tr><td class="paramname">device</td><td>OpenCL device to use. </td></tr>
    <tr><td class="paramname">type</td><td>Type of the values to scan.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <em>type</em> is not an integral type supported on the device. </td></tr>
    <tr><td class="paramname"><a class="el" href="classclogs_1_1InternalError.html" title="Exception thrown on internal errors that are not the user&#39;s fault. ">clogs::InternalError</a></td><td>if there was a problem with initialization.</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>This interface is deprecated as it does not scale with future feature additions. Use the constructor taking a <a class="el" href="classclogs_1_1ScanProblem.html">clogs::ScanProblem</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="acde3f6389fc52be74c8231ddd3b2df87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">clogs::Scan::Scan </td>
          <td>(</td>
          <td class="paramtype">const cl::Context &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cl::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclogs_1_1ScanProblem.html">ScanProblem</a> &amp;&#160;</td>
          <td class="paramname"><em>problem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>OpenCL context to use </td></tr>
    <tr><td class="paramname">device</td><td>OpenCL device to use. </td></tr>
    <tr><td class="paramname">problem</td><td>Description of the specific scan problem.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <em>problem</em> is not supported on the device or is not initialized. </td></tr>
    <tr><td class="paramname"><a class="el" href="classclogs_1_1InternalError.html" title="Exception thrown on internal errors that are not the user&#39;s fault. ">clogs::InternalError</a></td><td>if there was a problem with initialization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af6ad3dfe7cac4f39d0dc70db63fbfde0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clogs::Scan::enqueue </td>
          <td>(</td>
          <td class="paramtype">const cl::CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cl::Buffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::size_t&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>offset</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR_CLASS&lt; cl::Event &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Event *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueue a scan operation on a command queue (in-place). </p>
<p>This is equivalent to calling <code>enqueue</code>(<em>commandQueue</em>, <em>buffer</em>, <em>buffer</em>, <em>elements</em>, <em>offset</em>, <em>events</em>, <em>event</em>); </p>

</div>
</div>
<a class="anchor" id="a4b4884cf37a5948ca69d251e10466092"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clogs::Scan::enqueue </td>
          <td>(</td>
          <td class="paramtype">const cl::CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cl::Buffer &amp;&#160;</td>
          <td class="paramname"><em>inBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cl::Buffer &amp;&#160;</td>
          <td class="paramname"><em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::size_t&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>offset</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR_CLASS&lt; cl::Event &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Event *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueue a scan operation on a command queue. </p>
<p>An initial offset may optionally be passed in <em>offset</em>, which will be added to all elements of the result. The pointer must point to the type of element specified to the constructor. If no offset is desired, <code>NULL</code> may be passed instead.</p>
<p>The input and output buffers may be the same to do an in-place scan.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>The command queue to use. </td></tr>
    <tr><td class="paramname">inBuffer</td><td>The buffer to scan. </td></tr>
    <tr><td class="paramname">outBuffer</td><td>The buffer to fill with output. </td></tr>
    <tr><td class="paramname">elements</td><td>The number of elements to scan. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to add to all elements, or <code>NULL</code>. </td></tr>
    <tr><td class="paramname">events</td><td>Events to wait for before starting. </td></tr>
    <tr><td class="paramname">event</td><td>Event that will be signaled on completion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cl::Error</td><td>If <em>inBuffer</em> is not readable on the device. </td></tr>
    <tr><td class="paramname">cl::Error</td><td>If <em>outBuffer</em> is not writable on the device. </td></tr>
    <tr><td class="paramname">cl::Error</td><td>If the element range overruns the buffer. </td></tr>
    <tr><td class="paramname">cl::Error</td><td>If <em>elements</em> is zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><em>commandQueue</em> was created with the context and device given to the constructor. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>After execution, element <code>i</code> will be replaced by the sum of all elements strictly before <code>i</code>, plus the <em>offset</em> (if any). </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4ddfae11e9f0418afef0b5c23164b65a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clogs::Scan::enqueue </td>
          <td>(</td>
          <td class="paramtype">cl_command_queue&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_mem&#160;</td>
          <td class="paramname"><em>inBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_mem&#160;</td>
          <td class="paramname"><em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::size_t&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>offset</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_uint&#160;</td>
          <td class="paramname"><em>numEvents</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cl_event *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_event *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ac15311c66eb2ca7a2348cba656fffe52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clogs::Scan::enqueue </td>
          <td>(</td>
          <td class="paramtype">const cl::CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cl::Buffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::size_t&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cl::Buffer &amp;&#160;</td>
          <td class="paramname"><em>offsetBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_uint&#160;</td>
          <td class="paramname"><em>offsetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR_CLASS&lt; cl::Event &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Event *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueue a scan operation on a command queue, with an offset in a buffer (in-place). </p>
<p>This is equivalent to calling <code>enqueue</code>(<em>commandQueue</em>, <em>buffer</em>, <em>buffer</em>, <em>elements</em>, <em>offsetBuffer</em>, <em>offsetIndex</em>); </p>

</div>
</div>
<a class="anchor" id="a3ff4a4bc639c825357fed42e8c7ae9b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clogs::Scan::enqueue </td>
          <td>(</td>
          <td class="paramtype">const cl::CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cl::Buffer &amp;&#160;</td>
          <td class="paramname"><em>inBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cl::Buffer &amp;&#160;</td>
          <td class="paramname"><em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::size_t&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cl::Buffer &amp;&#160;</td>
          <td class="paramname"><em>offsetBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_uint&#160;</td>
          <td class="paramname"><em>offsetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR_CLASS&lt; cl::Event &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Event *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueue a scan operation on a command queue, with an offset in a buffer. </p>
<p>The offset is of the same type as the elements to be scanned, and is stored in a buffer. It is added to all elements of the result. It is legal for the offset to be in the same buffer as the values to scan, and it may even be safely overwritten by the scan (it will be read before being overwritten). This makes it possible to use do multi-pass algorithms with variable output. The counting pass fills in the desired allocations, a scan is used with one extra element at the end to hold the grand total, and the subsequent passes use this extra element as the offset.</p>
<p>The input and output buffers may be the same to do an in-place scan.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>The command queue to use. </td></tr>
    <tr><td class="paramname">inBuffer</td><td>The buffer to scan. </td></tr>
    <tr><td class="paramname">outBuffer</td><td>The buffer to fill with output. </td></tr>
    <tr><td class="paramname">elements</td><td>The number of elements to scan. </td></tr>
    <tr><td class="paramname">offsetBuffer</td><td>Buffer containing a value to add to all elements. </td></tr>
    <tr><td class="paramname">offsetIndex</td><td>Index (in units of the scan type) into <em>offsetBuffer</em>. </td></tr>
    <tr><td class="paramname">events</td><td>Events to wait for before starting. </td></tr>
    <tr><td class="paramname">event</td><td>Event that will be signaled on completion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cl::Error</td><td>If <em>inBuffer</em> is not readable on the device. </td></tr>
    <tr><td class="paramname">cl::Error</td><td>If <em>outBuffer</em> is not writable on the device. </td></tr>
    <tr><td class="paramname">cl::Error</td><td>If the element range overruns the buffer. </td></tr>
    <tr><td class="paramname">cl::Error</td><td>If <em>elements</em> is zero. </td></tr>
    <tr><td class="paramname">cl::Error</td><td>If <em>offsetBuffer</em> is not readable. </td></tr>
    <tr><td class="paramname">cl::Error</td><td>If <em>offsetIndex</em> overruns <em>offsetBuffer</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><em>commandQueue</em> was created with the context and device given to the constructor. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>After execution, element <code>i</code> will be replaced by the sum of all elements strictly before <code>i</code>, plus the offset. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a03a4be9a7fa18356ce82d80ebb29c215"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clogs::Scan::enqueue </td>
          <td>(</td>
          <td class="paramtype">cl_command_queue&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_mem&#160;</td>
          <td class="paramname"><em>inBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_mem&#160;</td>
          <td class="paramname"><em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::size_t&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_mem&#160;</td>
          <td class="paramname"><em>offsetBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_uint&#160;</td>
          <td class="paramname"><em>offsetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_uint&#160;</td>
          <td class="paramname"><em>numEvents</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cl_event *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_event *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/bruce/devel/clogs/include/clogs/<a class="el" href="scan_8h_source.html">scan.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceclogs.html">clogs</a></li><li class="navelem"><a class="el" href="classclogs_1_1Scan.html">Scan</a></li>
    <li class="footer">Generated on Thu May 10 2018 20:09:17 for CLOGS by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
